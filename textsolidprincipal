S.O.L.I.D é um acronimo para os cinco princícios de design atrelados a orientação a objeto (OOD) dado por Robert C. Martin, popularmente conhecido como Uncle Bob. 

Esses princícpios, quando combinados, tornam o desenvolvimento de software algo fácil de ser mantido e estendido. Esses princípios também evitam a formação de códigos ruins, permitem uma rápida refatoração do código, e também fazem parte de uma forma ágil e adaptativa de desenvolvimento de software. 

S.O.L.I.D é padrão para;

O Acrônimo, quando expandido, pode parecer ser algo complicado, contudo é bem fácil de entender;

S - Princípio da Responabilidade Única.
O - Princípio da Abertura e Fechamento. 
L - Princípio de substituição de Liskov. 
I - Princípio da segregação de interface. 
D - Princípio da Inversão de Dependência. 

Se faz necessário olhar para cada um desses princípios de forma individual para compreender porque eles são tão importantes. 

S - Princípio da Responabilidade Única.

A classe deve ter apenas uma única razão para mudar, significa que a classe deve ter apenas uma única função. 

Por exemplo, suponha que temos uma certa configuração e nós precisamos que o sol irradie para todas as áreas. Isso parece ser bem simples.  

class Circle {
    public $radius;

    public function construct($radius) {
        $this->radius = $radius;
    }
}

class Square {
    public $length;

    public function construct($length) {
        $this->length = $length;
    }
}

Nós criamos as classes de configuração e se tem construtores que solicitam um dado parâmetro. Pŕoximo, se cria a classe AreaCalculator com a seguinte lógica.   

class AreaCalculator {

    protected $shapes;

    public function __construct($shapes = array()) {
        $this->shapes = $shapes;
    }

    public function sum() {
        // logic to sum the areas
    }

    public function output() {
        return implode('', array(
            "",
                "Sum of the areas of provided shapes: ",
                $this->sum(),
            ""
        ));
    }
}

Para usar a classe AreaCalculator, nós simplesmente devemos instanciar a classe em um array na estrutura da configuração, como mostrado a seguir; 

$shape = array(
    new Circle(2),
    new Square(5),
    new Square(6)
);

$areas = new AreaCalculator($shape);

echo $areas->output();


O problema com o método output é que a classe AreaCalculator tem um dado carga de lógica e de dados. Então o que o usuário deseja como saída, um json ou algo deste gênero? 

Toda essa lógica deve ser uma alça para classe de AreaCalculator, que é contra isso que o SRP desaprova. Então para resolver esse problema se faz necessário ter uma uma classe que trabalhe
com esses retornos. 

$shapes = array(
    new Circle(2),
    new Square(5),
    new Square(6)
);

$areas = new AreaCalculator($shapes);
$output = new SumCalculatorOutputter($areas);

echo $output->JSON();
echo $output->HAML();
echo $output->HTML();
echo $output->JADE();

Agora a forma do retorno está relacionado com a classe SumCalculatorOutputter.



Open-closed Principle

Os objetos devem ser abertos para para extensões, mas fechado para modificações. 

Isso simplesmente significa que uma classe deve ser facilmente extensível sem que seja modificada. Vamos ver a classe AreaCalculator, especialmente o método de soma; 

public function sum() {
    foreach($this->shapes as $shape) {
        if(is_a($shape, 'Square')) {
            $area[] = pow($shape->length, 2);
        } else if(is_a($shape, 'Circle')) {
            $area[] = pi() * pow($shape->radius, 2);
        }
    }

    return array_sum($area);
}

Se nós queremos o método esteja habilitado para soma de áreas de formas diferentes, nós devemos adicionar mais um bloco if/else e isso será contra o princípio Open/Close.

O método de soma pode ser melhorado se a logica para calcular a área for removida da forma do método de soma e se for atachada na forma da classe.

class Square {
    public $length;

    public function __construct($length) {
        $this->length = $length;
    }

    public function area() {
        return pow($this->length, 2);
    }
}

>>>> The same thing should be done for the Circle class, an area method should be added. Now, to calculate the sum of any shape provided should be as simple as:

